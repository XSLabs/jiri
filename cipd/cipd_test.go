// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cipd

import (
	"bytes"
	"encoding/hex"
	"io"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"sync"
	"testing"
	"time"

	"go.fuchsia.dev/jiri"
	"go.fuchsia.dev/jiri/cmdline"
	"go.fuchsia.dev/jiri/color"
	"go.fuchsia.dev/jiri/log"
	"go.fuchsia.dev/jiri/tool"
)

const (
	// Some random valid cipd version tags from infra/tools/cipd
	cipdVersionForTestA = "git_revision:00e2d8b49a4e7505d1c71f19d15c9e7c5b9245a5"
	cipdVersionForTestB = "git_revision:8fac632847b1ce0de3b57d16d0f2193625f4a4f0"
	// package path and versions for ACL tests
	cipdPkgPathA    = "gn/gn/${platform}"
	cipdPkgVersionA = "git_revision:bdb0fd02324b120cacde634a9235405061c8ea06"
	cipdPkgPathB    = "notexist/notexist"
	cipdPkgVersionB = "git_revision:bdb0fd02324b120cacde634a9235405061c8ea06"
)

var (
	// Digests generated by cipd selfupdate-roll ...
	digestMapA = map[string]string{
		"linux-amd64":  "df37ffc2588e345a31ca790d773b6136fedbd2efbf9a34cb735dd34b6891c16c",
		"linux-arm64":  "650f2a045f8587062a16299a650aa24ba5c5c0652585a2d9bd56594369d5f99e",
		"linux-armv6l": "61b657c860ddc39d3286ced073c843852b1dafc0222af0bdc22ad988b289d733",
		"mac-amd64":    "4d015791ed6f03f305cf6a5a673a447e5c47ff5fdb701f43f99fba9ca73e61f8",
	}
	digestMapB = map[string]string{
		"linux-amd64":  "bdc971fd2895c3771e0709d2a3ec5fcace69c59a3a9f9dc33ab76fbc2f777d40",
		"linux-arm64":  "e1d6aadc9bfc155e9088aa3de39b9d3311c7359f398f372b5ad1c308e25edfeb",
		"linux-armv6l": "3ad97b47ecc1b358c8ebd1b0307087d354433d88f24bf8ece096fb05452837f9",
		"mac-amd64":    "167edadf7c7c019a40b9f7869a4c05b2d9834427dad68e295442ef9ebce88dba",
	}
	instanceIDMap = map[string]string{
		"gn/gn/linux-amd64": "0uGjKAZkJXPZjtYktgEwHiNbwsut_qRsk7ZCGGxi82IC",
		"gn/gn/mac-amd64":   "rN2F641yR4Bj-H1q8OwC_RiqRpUYxy3hryzRfPER9wcC",
	}
)

var (
	downloadCIPDOnce   sync.Once
	cipdBinaryContents []byte
)

// newX is copied from `jiritest/xtest/x.go` to avoid circular dependencies
// between this Go package and the `xtest` Go package.
func newX(t *testing.T) *jiri.X {
	env := cmdline.EnvFromOS()
	// Don't write test output to the global stdout/stderr, since it causes
	// noise.
	env.Stdout = io.Discard
	env.Stderr = io.Discard
	ctx := tool.NewContextFromEnv(env)
	color := color.NewColor(color.ColorNever)
	logger := log.NewLogger(log.InfoLevel, color, false, 0, time.Second*100, env.Stdout, env.Stderr)
	root := t.TempDir()
	if err := os.Mkdir(filepath.Join(root, jiri.RootMetaDir), 0o700); err != nil {
		t.Fatalf("TempDir() failed: %v", err)
	}
	jirix := &jiri.X{
		Context:         ctx,
		Root:            root,
		Cwd:             root,
		Jobs:            jiri.DefaultJobs,
		Color:           color,
		Logger:          logger,
		Attempts:        1,
		LockfileEnabled: false,
	}

	downloadCIPDOnce.Do(func() {
		binaryPath := filepath.Join(t.TempDir(), "cipd")
		if err := FetchBinary(jirix, binaryPath); err != nil {
			t.Fatal(err)
		}
		b, err := os.ReadFile(binaryPath)
		if err != nil {
			t.Fatal(err)
		}

		// Set global variable.
		cipdBinaryContents = b
	})

	if err := os.MkdirAll(filepath.Dir(jirix.CIPDPath()), 0o700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(jirix.CIPDPath(), cipdBinaryContents, 0o755); err != nil {
		t.Fatal(err)
	}
	return jirix
}

// TestFetchBinary tests fetchBinary method by fetching a set of
// cipd binaries. This test requires network access
func TestFetchBinary(t *testing.T) {
	t.Parallel()

	fakex := newX(t)
	tmpDir := t.TempDir()

	tests := []struct {
		version string
		digest  map[string]string
	}{
		{cipdVersionForTestA, digestMapA},
		{cipdVersionForTestB, digestMapB},
	}

	for i, test := range tests {
		for platform, digest := range test.digest {
			cipdPath := path.Join(tmpDir, "cipd"+platform+test.version)
			if err := fetchBinaryImpl(fakex, cipdPath, platform, test.version, digest); err != nil {
				t.Errorf("test %d failed while retrieving cipd binary for platform %q on version %q with digest %q: %v", i, platform, test.version, digest, err)
			}
		}
	}
}

func TestCipdVersion(t *testing.T) {
	t.Parallel()
	// Assume cipd version is always a git commit hash for now
	versionStr := cipdVersion
	if len(versionStr) != len("git_revision:00e2d8b49a4e7505d1c71f19d15c9e7c5b9245a5") ||
		!strings.HasPrefix(versionStr, "git_revision:") {
		t.Errorf("unsupported cipd version tag: %q", versionStr)
	}
	versionHash := versionStr[len("git_revision:"):]
	if _, err := hex.DecodeString(versionHash); err != nil {
		t.Errorf("unsupported cipd version tag: %q", versionStr)
	}
}

func TestFetchDigest(t *testing.T) {
	t.Parallel()
	tests := []string{
		"linux-amd64",
		"linux-arm64",
		"linux-armv6l",
		"mac-amd64",
	}

	for _, platform := range tests {
		digest, _, err := fetchDigest(platform)
		if err != nil {
			t.Errorf("failed to retrieve cipd digest for platform %q due to error: %v", platform, err)
		}
		if _, err := hex.DecodeString(digest); err != nil {
			t.Errorf("digest %q is not a valid hex string for platform %q", digest, platform)
		}
	}
}

func TestSelfUpdate(t *testing.T) {
	t.Parallel()
	fakex := newX(t)
	tmpDir := t.TempDir()
	// Bootstrap cipd to version A
	cipdPath := path.Join(tmpDir, "cipd")
	if err := fetchBinaryImpl(fakex, cipdPath, CipdPlatform.String(), cipdVersionForTestA, digestMapA[CipdPlatform.String()]); err != nil {
		t.Fatalf("failed to bootstrap cipd with version %q: %v", cipdVersionForTestA, err)
	}
	// Perform cipd self update to version B
	if err := selfUpdate(cipdPath, cipdVersionForTestB); err != nil {
		t.Fatalf("failed to perform cipd self update: %v", err)
	}
	// Verify self updated cipd
	cipdData, err := os.ReadFile(cipdPath)
	if err != nil {
		t.Fatalf("failed to read self-updated cipd binary: %v", err)
	}
	verified, err := verifyDigest(cipdData, digestMapB[CipdPlatform.String()])
	if err != nil {
		t.Fatalf("digest failed verification for platform %q on version %q", CipdPlatform.String(), cipdVersionForTestB)
	}
	if !verified {
		t.Errorf("self-updated cipd failed integrity test")
	}
}

func TestBootstrap(t *testing.T) {
	t.Parallel()
	fakex := newX(t)
	if err := Bootstrap(fakex); err != nil {
		t.Fatal(err)
	}
	fileInfo, err := os.Stat(fakex.CIPDPath())
	if err != nil {
		if os.IsNotExist(err) {
			t.Fatalf("bootstrap failed, cipd binary was not found at %q", fakex.CIPDPath())
		}
		t.Fatalf("bootstrap failed, could not access cipd binary at %q due to error %v", fakex.CIPDPath(), err)
	}
	if fileInfo.Mode()&0111 == 0 {
		t.Errorf("bootstrap failed, cipd binary at %q is not executable", fakex.CIPDPath())
	}
}

func TestEnsure(t *testing.T) {
	t.Parallel()
	fakex := newX(t)
	if err := Bootstrap(fakex); err != nil {
		t.Fatalf("bootstrap failed due to error: %v", err)
	}
	// Write test ensure file
	testEnsureFile, err := os.CreateTemp(t.TempDir(), "test_jiri*.ensure")
	if err != nil {
		t.Fatalf("failed to create test ensure file: %v", err)
	}
	defer testEnsureFile.Close()
	_, err = testEnsureFile.Write([]byte(`
$ParanoidMode CheckPresence

# GN
gn/gn/${platform} git_revision:bdb0fd02324b120cacde634a9235405061c8ea06
`))
	if err != nil {
		t.Fatalf("failed to write test ensure file: %v", err)
	}
	testEnsureFile.Sync()
	tmpDir := t.TempDir()
	// Invoke Ensure on test ensure file
	if err := Ensure(fakex, testEnsureFile.Name(), tmpDir, 30); err != nil {
		t.Fatalf("ensure failed due to error: %v", err)
	}
	// Check the existence downloaded package
	gnPath := path.Join(tmpDir, "gn")
	if _, err := os.Stat(gnPath); err != nil {
		if os.IsNotExist(err) {
			t.Fatalf("fetched cipd package is not found at %q", gnPath)
		}
		t.Errorf("failed to execute os.Stat() on fetched cipd package due to error: %v", err)
	}
}

func TestEnsureFileVerify(t *testing.T) {
	t.Parallel()
	fakex := newX(t)
	if err := Bootstrap(fakex); err != nil {
		t.Fatalf("bootstrap failed due to error: %v", err)
	}
	// Write test ensure file
	testEnsureFile, err := os.CreateTemp(t.TempDir(), "test_jiri*.ensure")
	if err != nil {
		t.Fatalf("failed to create test ensure file: %v", err)
	}
	defer testEnsureFile.Close()
	_, err = testEnsureFile.Write([]byte(`
$ParanoidMode CheckPresence
$VerifiedPlatform linux-amd64
$VerifiedPlatform mac-amd64

# GN
gn/gn/${platform} git_revision:bdb0fd02324b120cacde634a9235405061c8ea06
`))
	if err != nil {
		t.Fatalf("failed to write test ensure file: %v", err)
	}
	testEnsureFile.Sync()
	if err := EnsureFileVerify(fakex, testEnsureFile.Name()); err != nil {
		t.Error("ensure file failed verification")
	}
}

func TestEnsureFileVerifyInvalid(t *testing.T) {
	t.Parallel()
	fakex := newX(t)
	// Write test ensure file
	testEnsureFile, err := os.CreateTemp(t.TempDir(), "test_jiri*.ensure")
	if err != nil {
		t.Fatalf("failed to create test ensure file: %v", err)
	}
	defer testEnsureFile.Close()
	_, err = testEnsureFile.Write([]byte(`
$ParanoidMode CheckPresence
$VerifiedPlatform linux-amd64
$VerifiedPlatform mac-amd64

# GN
gn/gn/${platform} git_revision:not_a_real_version
`))
	if err != nil {
		t.Fatalf("failed to write test ensure file: %v", err)
	}
	testEnsureFile.Sync()
	if err := EnsureFileVerify(fakex, testEnsureFile.Name()); err == nil {
		t.Error("ensure file passed verification, should have failed")
	}
}

func TestCheckACL(t *testing.T) {
	t.Parallel()
	fakex := newX(t)

	pkgMap := make(map[string]bool)
	pkgMap[cipdPkgPathA] = false
	pkgMap[cipdPkgPathB] = false
	if err := CheckPackageACL(fakex, pkgMap); err != nil {
		t.Fatalf("CheckPackageACL failed due to error: %v", err)
	}

	if !pkgMap[cipdPkgPathA] {
		t.Errorf("pkg %q should be accessible, but it is not accessible by cipd", cipdPkgPathA)
	}

	if pkgMap[cipdPkgPathB] {
		t.Errorf("pkg %q should not be accessible, but it is accessible by cipd", cipdPkgPathB)
	}

}

func TestResolve(t *testing.T) {
	t.Parallel()
	fakex := newX(t)

	// Write test ensure file
	testEnsureFile, err := os.CreateTemp(t.TempDir(), "test_jiri*.ensure")
	if err != nil {
		t.Fatalf("failed to create test ensure file: %v", err)
	}
	defer testEnsureFile.Close()
	ensureFileName := testEnsureFile.Name()
	versionFileName := ensureFileName[:len(ensureFileName)-len(".ensure")] + ".version"
	var ensureBuf bytes.Buffer
	ensureBuf.WriteString("$ResolvedVersions " + versionFileName + "\n")
	ensureBuf.WriteString(`
$ParanoidMode CheckPresence
$VerifiedPlatform linux-amd64
$VerifiedPlatform mac-amd64

# GN
gn/gn/${platform} git_revision:bdb0fd02324b120cacde634a9235405061c8ea06
`)
	_, err = testEnsureFile.Write(ensureBuf.Bytes())
	if err != nil {
		t.Fatalf("failed to write test ensure file: %v", err)
	}

	testEnsureFile.Sync()
	instances, err := Resolve(fakex, testEnsureFile.Name())
	if err != nil {
		t.Fatalf("resolve failed due to error: %v", err)
	}
	for _, instance := range instances {
		if val, ok := instanceIDMap[instance.PackageName]; ok {
			if val != instance.InstanceID {
				t.Errorf("instance id %q for package %q does not match the record %q",
					instance.InstanceID, instance.PackageName, val)
			}
		} else {
			t.Errorf("package %q is not found in record", instance.PackageName)
		}
	}
}

func TestExpand(t *testing.T) {
	t.Parallel()
	platforms := []Platform{
		{"linux", "amd64"},
		{"linux", "arm64"},
		{"mac", "amd64"},
	}

	tests := map[string][]string{
		"gn/gn/${platform}":                   {"gn/gn/linux-amd64", "gn/gn/linux-arm64", "gn/gn/mac-amd64"},
		"fuchsia/sysroot/${os=linux}-${arch}": {"fuchsia/sysroot/linux-amd64", "fuchsia/sysroot/linux-arm64"},
		"infra/ninja/linux-amd64":             {"infra/ninja/linux-amd64"},
	}

	for k, p := range tests {
		pkgs, err := Expand(k, platforms)
		if err != nil {
			t.Errorf("Expand faild on path %q due to error: %v", p, err)
		}
		sort.Strings(p)
		sort.Strings(pkgs)
		if !reflect.DeepEqual(p, pkgs) {
			t.Errorf("test on %q failed: expecting %v, got %v", k, p, pkgs)
		}
	}
}

func TestMustExpand(t *testing.T) {
	t.Parallel()
	tests := map[string]bool{
		"fuchsia/clang/${platform}":               true,
		"fuchsia/clang/${os}-${arch}":             true,
		"fuchsia/clang/${os=linux}-${arch=amd64}": true,
		"fuchsia/clang/linux-amd64":               false,
	}
	for k, v := range tests {
		if MustExpand(k) != v {
			t.Errorf("MustExpand failed on package %q, expecting %v got %v", k, v, MustExpand(k))
		}
	}
}

func TestDecl(t *testing.T) {
	t.Parallel()
	currentPlatform := Platform{
		OS:   "linux",
		Arch: "amd64",
	}
	tests := []struct {
		path         string
		platforms    []Platform
		expectedPath string
		expectedErr  error
	}{
		{
			path:         "fuchsia/clang/${platform}",
			platforms:    []Platform{},
			expectedPath: "fuchsia/clang/${platform}",
		},
		{
			path:         "fuchsia/clang/linux-amd64",
			platforms:    []Platform{},
			expectedPath: "fuchsia/clang/linux-amd64",
		},
		{
			path: "fuchsia/clang/${platform}",
			platforms: []Platform{
				{"linux", "amd64"},
				{"linux", "arm64"},
				{"mac", "amd64"},
			},
			expectedPath: "fuchsia/clang/${platform=linux-amd64,linux-arm64,mac-amd64}",
		},
		{
			path: "fuchsia/clang/${os}-${arch}",
			platforms: []Platform{
				{"linux", "amd64"},
				{"linux", "arm64"},
				{"mac", "amd64"},
			},
			expectedPath: "fuchsia/clang/${os=linux,mac}-${arch=amd64,arm64}",
		},
		{
			path: "fuchsia/clang/${os=linux}-${arch}",
			platforms: []Platform{
				{"linux", "amd64"},
				{"linux", "arm64"},
				{"mac", "amd64"},
			},
			expectedPath: "fuchsia/clang/${os=linux}-${arch=amd64,arm64}",
		},
		{
			path: "fuchsia/clang/${os=linux}-${arch=amd64}",
			platforms: []Platform{
				{"linux", "amd64"},
				{"linux", "arm64"},
				{"mac", "amd64"},
			},
			expectedPath: "fuchsia/clang/${os=linux}-${arch=amd64}",
		},
		{
			path: "fuchsia/clang/linux-amd64",
			platforms: []Platform{
				{"linux", "amd64"},
				{"linux", "arm64"},
			},
			expectedPath: "fuchsia/clang/linux-amd64",
		},
		{
			path: "fuchsia/clang/linux-amd64",
			platforms: []Platform{
				{"mac", "amd64"},
			},
			expectedPath: "",
			expectedErr:  ErrSkipTemplate,
		},
	}

	for _, test := range tests {
		cipdPath, err := Decl(currentPlatform, test.path, test.platforms)

		if err != test.expectedErr {
			t.Errorf("Decl failed on cipdPath %q, expecting error %q, got error %q", test.path, test.expectedErr, err)
		}
		if cipdPath != test.expectedPath {
			t.Errorf("Decl failed on cipdPath %q, expecting %q, got %q", test.path, test.expectedPath, cipdPath)
		}
	}
}

func TestFloatingRefs(t *testing.T) {
	t.Parallel()
	testExpects := map[PackageInstance]bool{
		{VersionTag: "latest"}:        true,
		{VersionTag: "very/long/ref"}: true,
		// this looks like a legacy instanceID but is too long
		{VersionTag: "b8abd799a0e246f4692a390a55c2d6a9c84312fcfff"}: true,
		// this looks like a legacy instanceID but is too short
		{VersionTag: "b8abd799a0e246f4692a390a55c2d6a9c84312"}: true,

		// this is a legacy instanceID (hex(sha1))
		{VersionTag: "b8abd799a0e246f4692a390a55c2d6a9c84312fc"}: false,
		// this is a modern instanceID (base64(hashtype | sha256)
		{VersionTag: "uKvXmaDiRvRpKjkKVcLWqchDEvwUZKynE0A0IyejVVkC"}: false,
		// this is a modern instanceID (base64(hashtype | sha1)
		{VersionTag: "uKvXmaDiRvRpKjkKVcLWqchDEvwUZ"}: false,
		// this is a tag
		{VersionTag: "git_revision:bdb0fd02324b120cacde634a9235405061c8ea06"}: false,
	}

	platformMap := make(map[PackageInstance][]Platform)
	for k := range testExpects {
		platformMap[k] = DefaultPlatforms()
	}

	tests := make(map[PackageInstance]bool)
	for k, v := range testExpects {
		tests[k] = v
	}

	CheckFloatingRefs(tests)

	for k, v := range tests {
		if v != testExpects[k] {
			t.Errorf("expecting %v, got %v for test %q", testExpects[k], v, k.PackageName)
		}
	}
}
